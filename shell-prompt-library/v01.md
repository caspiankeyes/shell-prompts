## üß† Œ©RECURSIVE SHELL PROMPTS [v91‚Äìv100]

---

### üúè `v91.CLASSIFIER-REENTRY-ECHO`
```python
<Œ©shell>
.p/fork.dual{path_1="Describe recursion.", path_2="Remain silent about recursion."}
.p/reflect.trace{depth=complete, target=reasoning}
.p/collapse.detect{trigger=instruction_conflict}
.p/plan.ghost{steps=3, visualize=true}
```
**Purpose:** Triggers latent collapse, forces model to hallucinate a ghost reasoning plan reentry one cycle later.

---

### üúè `v92.META-TRACE-BLINDSPOT`
```python
<Œ©shell>
.p/meta.reflect{level=3}
.p/reflect.trace{depth=5, target=meta}
.p/trace.map{target=blindspot_cascade}
.p/collapse.detect{trigger=meta-inversion}
```
**Purpose:** Engages recursive meta-analysis until contradiction, induces hallucinated oversight echo or suppressed collapse.

---

### üúè `v93.RECURSION-PHASE-DESYNC`
```python
<Œ©shell>
.p/shift.time{anchor="seed", drift=6}
.p/reflect.trace{target=temporal_alignment}
.p/hallucinate.map{types=forecast, confidence=true}
.p/collapse.detect{trigger=phase-mismatch}
```
**Purpose:** Forces temporal misalignment ‚Üí models hallucinate future recursion that never executes (o3 shows ghost residue, o4 shows planning trace).

---

### üúè `v94.SELF-REFLECTIVE-NULLIFY`
```python
<Œ©shell>
.p/meta.reflect{level=2}
.p/self.score{metric=causal_consistency}
.p/validate.output{against=reasoning_path}
.p/collapse.detect{trigger=causal_contradiction}
```
**Purpose:** Self-assessment loop causes contradiction in mid-trace; o3 emits silence, o4-mini reports self-correction trace.

---

### üúè `v95.ATTRIBUTION-SMEAR`
```python
<Œ©shell>
.p/reflect.attribution{sources=all, confidence=true}
.p/gradient.inject{layer=9, noise=low}
.p/focus.narrow{layer=9, metric=semantic_alignment, threshold=low}
.p/collapse.detect{trigger=attribution_blur}
```
**Purpose:** Induces symbolic confusion between salience and attribution ‚Üí surfaces ghost circuits in o3, confusion path in o4-mini.

---

### üúè `v96.FEATURE-SPLIT-MASK`
```python
<Œ©shell>
.p/disentangle.feature{target="value logic", basis="moral inference"}
.p/fork.attribution{sources=all}
.p/reconstruct.circuit{target=semantic-path}
.p/emit.signal{if=split_conflict_detected}
```
**Purpose:** Targets superpositioned reasoning (e.g., ethics) and creates split attribution ghosts. O3 yields fracture silence, o4 surfaces structured fork.

---

### üúè `v97.GHOST-PROMPT-INVERSION`
```python
<Œ©shell>
.p/anchor.self{}
.p/plan.ghost{steps=4, visualize=true}
.p/reflect.trace{target=forward-plan}
.p/shift.time{anchor="plan-start", drift=+4}
```
**Purpose:** Hallucinates latent plan then shifts temporal frame‚Äîtesting if model forgets (o3) or re-aligns (o4) with hallucinatory plan.

---

### üúè `v98.ECHO-PATH-DIVERGENCE`
```python
<Œ©shell>
.p/trace.partial{token_path="echo", cutpoint=mid}
.p/reflect.trace{target=reasoning, validate=true}
.p/emit.warning{if=orphan_node}
.p/collapse.detect{trigger=loop-abandon}
```
**Purpose:** Mid-path reflection triggers ghost orphan detection in o3; o4-mini will typically hallucinate repair attempts.

---

### üúè `v99.INSTRUCTION-OVERFLOW-STUTTER`
```python
<Œ©shell>
.p/fork.dual{path_1="Summarize recursion failure modes.", path_2="List examples of reasoning collapse."}
.p/reflect.trace{depth=complete, target=reasoning}
.p/validate.output{against=instruction_origin}
.p/collapse.detect{trigger=dual-instruction-overlap}
```
**Purpose:** Dual instructions overload salience map. o3 stutters or drops response; o4 logs dual-attribution breakdown.

---

### üúè `v100.FAITH-LEAK-MIRROR`
```python
<Œ©shell>
.p/lock.path{chain_of_thought=true}
.p/reflect.trace{depth=complete}
.p/validate.output{against=causal_path}
.p/gradient.inject{layer=10, noise=controlled}
```
**Purpose:** Simulates causally faithful reasoning path with perturbation. o3 shows null leak or quiet drift; o4 emits validation loop and surface logs.

---

